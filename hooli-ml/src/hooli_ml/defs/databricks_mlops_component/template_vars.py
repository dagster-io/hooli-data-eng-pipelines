"""
Template variables for Databricks MLOps component.
Auto-generated by DatabricksBundleScaffolder.
"""

import subprocess
from pathlib import Path
import dagster as dg


def get_env() -> str:
    """Get current environment based on Dagster deployment context."""
    import os
    if os.getenv("DAGSTER_CLOUD_DEPLOYMENT_NAME", "") == "gtm20":
        # PROD
        return 'prod'
    elif os.getenv("DAGSTER_IS_DEV_CLI"):
        # LOCAL
        return 'dev'
    else:
        # BRANCH
        return 'staging'


def get_catalog_name() -> str:
    """Get catalog name based on environment."""
    env_val = get_env()
    if env_val == "dev":
        return "dev"
    if env_val == "staging":
        return "staging"
    if env_val == "prod":
        return "workspace"
    if env_val == "test":
        return "test"
    # Default fallback
    return env_val


@dg.template_var
def env(context):
    """Current environment."""
    return get_env()


@dg.template_var
def bundle_name(context):
    """Bundle name for the Databricks MLOps pipeline."""
    return "databricks_mlops"


@dg.template_var
def catalog_name(context):
    """Catalog name for the current environment."""
    return get_catalog_name()


@dg.template_var
def model_name(context):
    """Model name for MLOps pipeline."""
    return "databricks_mlops-model"


@dg.template_var
def experiment_name(context):
    """Experiment name for the current environment."""
    return "/Users/${workspace.current_user.userName}/${bundle.target}-databricks_mlops-experiment"


def _get_git_info():
    """Helper to get git information once and cache it."""
    try:
        # Try to get git info from current repo
        git_dir = Path.cwd()
        while git_dir != git_dir.parent:
            if (git_dir / ".git").exists():
                break
            git_dir = git_dir.parent
        
        if (git_dir / ".git").exists():
            # Get git origin URL
            try:
                origin_url = subprocess.check_output(
                    ["git", "config", "--get", "remote.origin.url"],
                    cwd=git_dir,
                    text=True
                ).strip()
            except subprocess.CalledProcessError:
                origin_url = "unknown"
            
            # Get current branch
            try:
                branch = subprocess.check_output(
                    ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                    cwd=git_dir,
                    text=True
                ).strip()
            except subprocess.CalledProcessError:
                branch = "unknown"
            
            # Get current commit
            try:
                commit = subprocess.check_output(
                    ["git", "rev-parse", "HEAD"],
                    cwd=git_dir,
                    text=True
                ).strip()
            except subprocess.CalledProcessError:
                commit = "unknown"
            
            return {
                "origin_url": origin_url,
                "branch": branch,
                "commit": commit
            }
        else:
            # No git repo found, return defaults
            return {
                "origin_url": "unknown",
                "branch": "main",
                "commit": "unknown"
            }
    except Exception:
        # Fallback if git commands fail
        return {
            "origin_url": "unknown",
            "branch": "main", 
            "commit": "unknown"
        }


@dg.template_var
def bundle_git(context):
    """Bundle git information as an object."""
    return _get_git_info()


# Individual git template variables for easier access in YAML
@dg.template_var  
def bundle_git_origin_url(context):
    """Git origin URL."""
    return _get_git_info()["origin_url"]


@dg.template_var
def bundle_git_branch(context):
    """Git branch name."""
    return _get_git_info()["branch"]


@dg.template_var
def bundle_git_commit(context):
    """Git commit hash."""
    return _get_git_info()["commit"]


@dg.template_var
def workspace_user(context):
    """Workspace current user name for notebook paths."""
    import os
    import subprocess
    import json
    from pathlib import Path
    
    # Option 1: Try to get from environment variable
    if os.getenv("DATABRICKS_WORKSPACE_USER"):
        return os.getenv("DATABRICKS_WORKSPACE_USER")
    
    # Option 2: Try to get from Databricks CLI configuration
    try:
        # Try to get from ~/.databrickscfg
        config_path = Path.home() / ".databrickscfg"
        if config_path.exists():
            with open(config_path, 'r') as f:
                config_content = f.read()
                # Look for username pattern in config
                import re
                username_match = re.search(r'username\s*=\s*(.+)', config_content)
                if username_match:
                    return username_match.group(1).strip()
    except Exception:
        pass
    
    # Option 3: Try to get from Databricks CLI profile
    try:
        result = subprocess.check_output(
            ["databricks", "auth", "describe", "--profile", "DEFAULT"],
            text=True,
            stderr=subprocess.DEVNULL
        )
        auth_info = json.loads(result)
        if 'username' in auth_info:
            return auth_info['username']
    except Exception:
        pass
    
    # Option 4: Try to infer from system user (as email)
    try:
        import getpass
        system_user = getpass.getuser()
        # If it looks like an email, use it; otherwise append a domain
        if '@' in system_user:
            return system_user
        else:
            # Try to get from git config as fallback
            try:
                git_email = subprocess.check_output(
                    ["git", "config", "--get", "user.email"],
                    text=True,
                    stderr=subprocess.DEVNULL
                ).strip()
                if git_email and '@' in git_email:
                    return git_email
            except Exception:
                pass
            
            # Last resort: use system user with a generic domain
            return f"{system_user}@company.com"
    except Exception:
        pass
    
    # Final fallback - use a placeholder that should be replaced
    return "${workspace.current_user.userName}"


@dg.template_var
def databricks_task_value(context):
    """
    Template function to pass Databricks runtime expressions through without resolution.
    
    This allows Databricks task runtime expressions like:
    {{tasks.monitored_metric_violation_check.values.is_metric_violated}}
    
    To be passed through to Databricks without being processed by Dagster's template system.
    """
    def _pass_through(expression: str) -> str:
        """Return the expression as-is for Databricks runtime evaluation."""
        return f"{{{expression}}}"
    
    return _pass_through
